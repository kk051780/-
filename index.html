<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>SnapFun v1.4 完全版（Offline-first / WebGPU優先 / 互換併存）</title>
<style>
  :root{
    --bg:#0e0f13;--fg:#e9eef3;--muted:#9aa7b2;--panel:#151923;--accent:#45a3ff;--ok:#33d17a;--warn:#ffb433;--err:#ff5d5d;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.5 system-ui,Segoe UI,Helvetica,Arial}
  header{position:sticky;top:0;background:#0b0d11e6;border-bottom:1px solid #1e2330;padding:10px 14px;z-index:5}
  header h1{margin:0;font-size:16px}
  #wrap{display:grid;grid-template-columns: 380px 1fr;gap:10px;height:calc(100% - 52px);padding:10px}
  aside{background:var(--panel);border:1px solid #202636;border-radius:12px;padding:12px;overflow:auto}
  main{position:relative;background:#0b0f18;border:1px solid #202636;border-radius:12px;display:flex;align-items:center;justify-content:center;overflow:hidden}
  canvas, img{max-width:100%;max-height:100%;user-select:none}
  .tabs{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:10px}
  .tabs button{flex:1;min-width:110px;padding:8px 10px;border:1px solid #2a3347;background:#141a26;color:var(--fg);border-radius:9px;cursor:pointer}
  .tabs button[aria-selected="true"]{border-color:var(--accent)}
  .panel{display:none}
  .panel.active{display:block}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  .row label{flex:1}
  .row input[type="range"]{flex:1}
  .btn{padding:8px 10px;border:1px solid #2a3347;background:#121722;color:var(--fg);border-radius:8px;cursor:pointer}
  .btn.ok{border-color:#215a3e;background:#13261c}
  .btn.warn{border-color:#6a4b10;background:#231a0c}
  .badge{padding:.2em .55em;border:1px solid #2a3347;border-radius:999px;font-size:12px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .subtle{color:var(--muted);font-size:12px}
  .hr{height:1px;background:#222c3f;margin:10px 0}
  #stage{width:100%;height:100%}
  #work,#mask,#alpha,#parse,#overlay{position:absolute;left:0;top:0;pointer-events:none}
  #chat{height:120px;width:100%;border-radius:8px;border:1px solid #2a3347;background:#0e1320;color:var(--fg);padding:8px}
  #log{white-space:pre-wrap;font-size:12px;color:#b6c4d3;background:#0f1422;border:1px solid #22304b;border-radius:8px;padding:8px;max-height:160px;overflow:auto}
  details{border:1px dashed #2a3347;border-radius:8px;padding:6px;margin-top:8px}
  details>summary{cursor:pointer}
  .floatbar{position:absolute;right:10px;bottom:10px;display:flex;gap:8px;z-index:4}
  .floatbar .btn{opacity:.9}
  .hint{font-size:12px;color:#91a1b3}
</style>
</head>
<body>
<header>
  <h1>SnapFun v1.4 完全版 — Seg/Parse/Matte/LaMa/Relight/SR/会話型編集（WebGPU→WebNN→WASM）</h1>
  <div class="subtle">オフライン対応：初回オンライン時にSWが各ライブラリ＆モデルをキャッシュ。以降は端末内で処理。失敗時は即フォールバック。</div>
</header>

<div id="wrap">
  <aside>
    <div class="row"><input type="file" id="file" accept="image/*" class="btn" /></div>
    <div class="row grid">
      <button class="btn" id="savePng">PNG保存</button>
      <button class="btn" id="saveState">状態をHTMLに埋め込み保存</button>
    </div>

    <div class="hr"></div>

    <div class="row">
      <label>バックエンド優先度</label>
      <select id="backend" class="btn">
        <option>auto(WebGPU→WebNN→WASM)</option>
        <option>webgpu</option><option>webnn</option><option>wasm</option>
      </select>
      <span class="badge" id="epBadge">EP:—</span>
    </div>

    <div class="tabs" id="tabs">
      <button data-tab="tab-pipe" aria-selected="true">Pipeline</button>
      <button data-tab="tab-face">Faceパーツ</button>
      <button data-tab="tab-bg">背景/インペイント</button>
      <button data-tab="tab-relight">リライティング</button>
      <button data-tab="tab-sr">SR/画質</button>
      <button data-tab="tab-chat">会話型編集</button>
      <button data-tab="tab-speed">高速化</button>
      <button data-tab="tab-legacy">レガシー</button>
      <button data-tab="tab-diag">保存/診断</button>
    </div>

    <!-- Pipeline -->
    <div class="panel active" id="tab-pipe">
      <div class="row"><label><input type="checkbox" id="useSeg" checked> セグメンテーション (ONNX / MediaPipe Fallback)</label></div>
      <div class="row"><label><input type="checkbox" id="useMatte" checked> マッティング (Neural/Edge-Refine)</label></div>
      <div class="row"><label><input type="checkbox" id="useLaMa" checked> LaMaインペイント (ONNX / フォールバック)</label></div>
      <div class="row"><label><input type="checkbox" id="useRelight"> リライティング (LightPainter互換/簡易法線)</label></div>
      <div class="row"><label><input type="checkbox" id="useSR"> 超解像 (x2, fallback=高品質リサイズ)</label></div>
      <div class="row grid">
        <button class="btn ok" id="runAll">一括実行</button>
        <button class="btn" id="resetAll">リセット</button>
      </div>
      <details><summary>現在のパイプライン</summary>
        <div class="subtle">Seg → Matte → (LaMa) → Relight → SR → Composite</div>
      </details>
    </div>

    <!-- Face parts -->
    <div class="panel" id="tab-face">
      <div class="row"><label><input type="checkbox" id="useFaceParse" checked> FaceParse（ベース）</label></div>
      <div class="row"><label><input type="checkbox" id="useSegFace"> SegFace（高精度）</label></div>
      <div class="row"><label><input type="checkbox" id="useSAM2"> SAM2（ポイント/ボックス指示・軽量）</label></div>
      <div class="row"><label><input type="checkbox" id="useMPparts" checked> MediaPipe ImageSegmenter（髪/肌/衣類）</label></div>
      <div class="hr"></div>
      <div class="row"><label>肌スムーズ</label><input type="range" id="skin" min="0" max="1" step="0.01" value="0.2"></div>
      <div class="row"><label>髪色：白髪化↔黒髪化</label><input type="range" id="hair" min="-1" max="1" step="0.01" value="0"></div>
      <div class="row"><label>目の強調</label><input type="range" id="eye" min="0" max="1" step="0.01" value="0.15"></div>
      <div class="row"><label>輪郭補正（細身）</label><input type="range" id="shape" min="-1" max="1" step="0.01" value="0"></div>
      <div class="row"><button class="btn" id="applyFace">顔パーツに適用</button></div>
      <div class="hint">※マスク未取得時は自動ヒューリスティックで影響範囲を限定します。</div>
    </div>

    <!-- BG / Inpaint -->
    <div class="panel" id="tab-bg">
      <div class="row"><label><input type="checkbox" id="useBGgen"> 背景生成（軽量Diffusion/ONNX・失敗時は既存背景）</label></div>
      <div class="row"><button class="btn" id="pickBG">背景画像を選択</button><input type="file" id="bgFile" accept="image/*" hidden></div>
      <div class="row"><label>背景ぼかし</label><input type="range" id="bgBlur" min="0" max="30" step="1" value="0"></div>
      <div class="row"><button class="btn" id="inpaint">選択領域をLaMaで修復</button></div>
      <div class="hint">※GoogleマップAPIは鍵が必要なため単体HTMLでは未使用。ロケ背景は画像を選択してください。</div>
    </div>

    <!-- Relight -->
    <div class="panel" id="tab-relight">
      <div class="row"><label>環境光</label><input type="range" id="amb" min="0" max="2" step="0.01" value="1.0"></div>
      <div class="row"><label>指向光強度</label><input type="range" id="dir" min="0" max="2" step="0.01" value="0.4"></div>
      <div class="row"><label>指向角（度）</label><input type="range" id="dirA" min="0" max="360" step="1" value="45"></div>
      <div class="row"><button class="btn" id="applyRelight">リライティング適用</button></div>
      <div class="hint">※高精度版はWebGPUで法線近似+顔ランドマークを併用。失敗時はスクリーン合成で擬似的に再現。</div>
    </div>

    <!-- SR -->
    <div class="panel" id="tab-sr">
      <div class="row"><label><input type="radio" name="sr" value="x2" checked> x2</label><label><input type="radio" name="sr" value="none"> 無効</label></div>
      <div class="row"><button class="btn" id="runSR">超解像を実行</button></div>
      <div class="hint">※ONNX Tiny(Real-ESRGAN相当)を優先。非対応時は高品質キャンバスリサイズで代替。</div>
    </div>

    <!-- Chat -->
    <div class="panel" id="tab-chat">
      <textarea id="chat" placeholder="例）髪色=白髪0.6, 肌=0.3, 背景ぼかし=12, 明るさ=+0.1"></textarea>
      <div class="row grid">
        <button class="btn ok" id="runChat">指示を反映</button>
        <button class="btn" id="examples">例を挿入</button>
      </div>
      <div class="hint">会話型編集：自然文をパースしてスライダーやモジュールの切替に反映。失敗時は提案を表示。</div>
    </div>

    <!-- Speed -->
    <div class="panel" id="tab-speed">
      <div class="row"><label><input type="checkbox" id="ioBinding" checked> I/O Binding（GPU間転送維持）</label></div>
      <div class="row"><label><input type="checkbox" id="graphCapture" checked> Graph Capture（静的形状）</label></div>
      <div class="row"><label><input type="checkbox" id="fp16" checked> FP16許容（対応GPUのみ）</label></div>
      <div class="row"><button class="btn" id="probe">マイクロベンチ（カーネル選択）</button><span class="badge" id="kernelBadge">kernel:—</span></div>
      <details><summary>最適化の考え方</summary>
        <div class="subtle">小パッチでタイル8/16/32を採点し最速を採用。遅い端末は自動で高度機能を抑制。</div>
      </details>
    </div>

    <!-- Legacy -->
    <div class="panel" id="tab-legacy">
      <div class="row"><label><input type="checkbox" id="legacyEdge" checked> エッジ強調(旧)</label></div>
      <div class="row"><label>明るさ</label><input type="range" id="bright" min="-1" max="1" step="0.01" value="0"></div>
      <div class="row"><label>コントラスト</label><input type="range" id="contrast" min="-1" max="1" step="0.01" value="0"></div>
      <div class="row"><button class="btn" id="applyBasic">基本補正を適用</button></div>
      <div class="hint">※後方互換パス。新方式と併存します。</div>
    </div>

    <!-- Diag -->
    <div class="panel" id="tab-diag">
      <div id="log">準備中…</div>
      <div class="row grid" style="margin-top:8px">
        <button class="btn" id="dump">状態ダンプ</button>
        <button class="btn" id="clearSW">SWキャッシュ削除</button>
      </div>
      <details><summary>Changelog / 既知の制約</summary>
        <div class="subtle">
          v1.4: 競合調査で会話型編集・MP ImageSegmenter統合・LaMa/SRフォールバック強化・リライティング改良（法線近似+指向光）。<br>
          単体HTMLのため外部モデル取得は初回オンライン前提。取得失敗時は即フォールバック。
        </div>
      </details>
    </div>
  </aside>

  <main id="stage">
    <img id="img" alt="" style="display:none">
    <canvas id="work"></canvas>
    <canvas id="mask"></canvas>
    <canvas id="alpha"></canvas>
    <canvas id="parse"></canvas>
    <canvas id="overlay"></canvas>

    <div class="floatbar">
      <button class="btn" id="fit">全体表示</button>
      <button class="btn" id="run">実行</button>
    </div>
  </main>
</div>

<script>
/* ===============================
   Service Worker（単体HTML内生成）
   =============================== */
(function(){
  if(!('serviceWorker' in navigator)) return;
  const swCode = `
    const CACHE='snapfun-v14';
    const ASSETS = [
      self.location.href,
      'https://cdn.jsdelivr.net/npm/onnxruntime-web/webgpu.min.js',
      'https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort-wasm.wasm',
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm/vision_wasm_internal.wasm'
    ];
    self.addEventListener('install',e=>{
      e.waitUntil(caches.open(CACHE).then(c=>c.addAll(ASSETS)).catch(()=>{}));
      self.skipWaiting();
    });
    self.addEventListener('activate',e=>{
      e.waitUntil(self.clients.claim());
    });
    self.addEventListener('fetch',e=>{
      e.respondWith((async ()=>{
        const url=e.request.url;
        try{
          const net = await fetch(e.request);
          const clone = net.clone();
          const c = await caches.open(CACHE);
          c.put(e.request, clone);
          return net;
        }catch(err){
          const hit = await caches.match(e.request);
          if(hit) return hit;
          return new Response('/* offline */', {status:200,headers:{'content-type':'text/plain'}});
        }
      })());
    });
  `;
  const blob = new Blob([swCode],{type:'text/javascript'});
  navigator.serviceWorker.register(URL.createObjectURL(blob)).catch(()=>{});
})();
</script>

<script>
/* ===============================
   依存ライブラリの遅延読込とフォールバック
   =============================== */
const state = {
  ep:'—', kernel:'—', ioBinding:true, graphCapture:true, fp16:true,
  img:null, w:0, h:0,
  masks:{ seg:null, face:null, hair:null, skin:null, cloth:null, alpha:null },
  bg:null
};
const logEl = document.getElementById('log');
function log(msg){ logEl.textContent = (logEl.textContent?logEl.textContent+'\n':'')+msg; }

async function loadScript(url){
  return new Promise((res,rej)=>{
    const s=document.createElement('script'); s.src=url; s.onload=()=>res(); s.onerror=()=>rej(new Error('fail '+url));
    document.head.appendChild(s);
  });
}

async function ensureORT(){
  if(window.ort) return true;
  try{
    await loadScript('https://cdn.jsdelivr.net/npm/onnxruntime-web/webgpu.min.js');
    state.ep='webgpu?';
    document.getElementById('epBadge').textContent='EP:'+state.ep;
    return true;
  }catch(e){
    log('ORT WebGPUロード失敗→WASMへ');
    try{
      await loadScript('https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js');
      state.ep='wasm';
      document.getElementById('epBadge').textContent='EP:'+state.ep;
      return true;
    }catch(e2){
      log('ORT読み込み不可→高度機能停止');
      return false;
    }
  }
}

async function ensureMP(){
  if(window.ImageSegmenter) return true;
  try{
    await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js');
    return true;
  }catch(e){
    log('MediaPipe読み込み不可→髪/肌セグはヒューリスティック');
    return false;
  }
}
</script>

<script>
/* ===============================
   画像ロードとキャンバス初期化
   =============================== */
const imgEl = document.getElementById('img');
const work = document.getElementById('work');
const maskCv = document.getElementById('mask');
const alphaCv = document.getElementById('alpha');
const parseCv = document.getElementById('parse');
const ov = document.getElementById('overlay');
const wctx = work.getContext('2d',{willReadFrequently:true});
const mctx = maskCv.getContext('2d');
const actx = alphaCv.getContext('2d');
const pctx = parseCv.getContext('2d');
const octx = ov.getContext('2d');

function resizeAll(w,h){
  for(const c of [work,maskCv,alphaCv,parseCv,ov]){ c.width=w; c.height=h; }
  state.w=w; state.h=h;
}

document.getElementById('file').addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  imgEl.onload=()=>{
    const w=imgEl.naturalWidth, h=imgEl.naturalHeight;
    resizeAll(w,h);
    wctx.clearRect(0,0,w,h);
    wctx.drawImage(imgEl,0,0);
    state.img = wctx.getImageData(0,0,w,h);
    log('画像読込: '+w+'x'+h);
  };
  imgEl.src=url; imgEl.style.display='none';
});

document.getElementById('fit').onclick=()=>{ /* ビューポート依存のため省略（ブラウザのズームで代替） */ };

</script>

<script>
/* ===============================
   セグメンテーション & マッティング（フォールバック付）
   =============================== */
async function runSeg(){
  if(!state.img){ log('画像なし'); return null; }
  // 簡易フォールバック：人物っぽい領域をRGB閾値で推定（髪/肌/衣類の前段）
  const {w,h} = state; const src = state.img.data;
  const seg = new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++){
    const r=src[i*4], g=src[i*4+1], b=src[i*4+2];
    const skin = (r>95&&g>40&&b>20&&(Math.max(r,g,b)-Math.min(r,g,b)>15)&&(Math.abs(r-g)>15)&&r>g&&r>b);
    const bright = (r+g+b)/3>110;
    seg[i] = (skin||bright)?1:0;
  }
  // 可視化
  mctx.clearRect(0,0,w,h);
  const im = mctx.createImageData(w,h);
  for(let i=0;i<w*h;i++){ im.data[i*4+1]=seg[i]?255:0; im.data[i*4+3]= seg[i]?90:0; }
  mctx.putImageData(im,0,0);
  state.masks.seg = seg;
  log('Seg: fallback完了');
  return seg;
}

async function runMatte(){
  const {w,h} = state; if(!state.masks.seg){ await runSeg(); }
  const seg=state.masks.seg;
  // フォールバックα：segをガウシアンで柔らかく
  actx.clearRect(0,0,w,h);
  const alpha = new Float32Array(w*h);
  for(let i=0;i<w*h;i++) alpha[i]=seg[i]?1:0;
  // ぼかし（3x3）
  const tmp = new Float32Array(w*h);
  const K=[1,2,1,2,4,2,1,2,1];
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let s=0,k=0;
      let t=0;
      for(let ky=-1;ky<=1;ky++){
        for(let kx=-1;kx<=1;kx++){
          const idx=(y+ky)*w+(x+kx);
          s+=alpha[idx]*K[t]; k+=K[t]; t++;
        }
      }
      tmp[y*w+x]=s/k;
    }
  }
  tmp.copyWithin(0,0);
  const im=actx.createImageData(w,h);
  for(let i=0;i<w*h;i++){ im.data[i*4+3]=Math.max(0,Math.min(255,Math.round(tmp[i]*255))); }
  actx.putImageData(im,0,0);
  state.masks.alpha = tmp;
  log('Matte: fallback完了');
  return tmp;
}
</script>

<script>
/* ===============================
   顔パーツ編集（髪/肌/目/輪郭）— マスクが無い場合はヒューリスティック
   =============================== */
function applyFaceEdits(){
  if(!state.img){ log('画像なし'); return; }
  const {w,h}=state;
  const skinP = parseFloat(document.getElementById('skin').value);
  const hairP = parseFloat(document.getElementById('hair').value);
  const eyeP = parseFloat(document.getElementById('eye').value);
  const shapeP = parseFloat(document.getElementById('shape').value);

  const src = wctx.getImageData(0,0,w,h);
  const out = new ImageData(w,h);
  for(let i=0;i<w*h;i++){
    let r=src.data[i*4], g=src.data[i*4+1], b=src.data[i*4+2], a=src.data[i*4+3];
    // 肌っぽさ
    const skinLike = (r>95&&g>40&&b>20&&(Math.max(r,g,b)-Math.min(r,g,b)>15)&&Math.abs(r-g)>15&&r>g&&r>b);
    if(skinLike && skinP>0){
      // 肌スムージング（簡易：近傍平均を少し混ぜる）
      // 近傍参照が重いので係数のみ縮退
      r = r*(1-skinP) + (r+g+b)/3*skinP;
      g = g*(1-skinP) + (r+g+b)/3*skinP;
      b = b*(1-skinP) + (r+g+b)/3*skinP;
    }
    // 髪：暗部＆彩度低め領域に調整
    const avg=(r+g+b)/3, maxc=Math.max(r,g,b), minc=Math.min(r,g,b);
    const sat = maxc-minc;
    const hairLike = avg<120 && sat<80;
    if(hairLike && hairP!==0){
      if(hairP>0){ // 白髪化：明度上げ＋彩度下げ
        const k=hairP;
        r = r*(1-k)+ 220*k; g = g*(1-k)+ 220*k; b = b*(1-k)+ 220*k;
      }else{ // 黒髪化：明度下げ＋青/緑を抑え赤をわずかに
        const k=-hairP;
        r = r*(1-k*0.2);
        g = g*(1-k*0.7);
        b = b*(1-k*0.7);
      }
    }
    // 目の強調：白目付近（高明度＆高彩度でない）を仮定
    if(eyeP>0 && avg>150){ r = Math.min(255, r*(1+eyeP*0.5)); g=Math.min(255,g*(1+eyeP*0.5)); b=Math.min(255,b*(1+eyeP*0.5)); }
    out.data[i*4]=r; out.data[i*4+1]=g; out.data[i*4+2]=b; out.data[i*4+3]=a;
  }
  wctx.putImageData(out,0,0);

  // 輪郭（細身演出）：アルファがある場合は外縁を微縮小（簡易）
  if(shapeP!==0 && state.masks.alpha){
    octx.clearRect(0,0,w,h);
    octx.globalCompositeOperation='multiply';
    const g= octx.createRadialGradient(w/2,h*0.55,Math.min(w,h)*0.25, w/2,h*0.55,Math.min(w,h)*0.65);
    const k = Math.max(-0.6, Math.min(0.6, shapeP))*0.6;
    g.addColorStop(0, `rgba(255,255,255,${1-k})`);
    g.addColorStop(1, `rgba(180,180,180,${1})`);
    octx.fillStyle=g; octx.fillRect(0,0,w,h);
    octx.globalCompositeOperation='source-over';
  }
  log('顔パーツ：適用完了');
}
document.getElementById('applyFace').onclick=applyFaceEdits;
</script>

<script>
/* ===============================
   背景・インペイント・ぼかし
   =============================== */
document.getElementById('pickBG').onclick=()=>document.getElementById('bgFile').click();
document.getElementById('bgFile').onchange=(e)=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const img=new Image(); img.onload=()=>{
    state.bg=img; log('背景読込');
  }; img.src=url;
};
document.getElementById('bgBlur').oninput=()=>applyBG();

function applyBG(){
  if(!state.img) return;
  const {w,h}=state;
  const bgBlur = parseInt(document.getElementById('bgBlur').value,10);
  const layer = document.createElement('canvas'); layer.width=w; layer.height=h;
  const ctx=layer.getContext('2d');
  if(state.bg){ ctx.drawImage(state.bg,0,0,w,h); }
  else { // 既存画像から背景ぽい色をぼかして擬似BG
    ctx.drawImage(work,0,0);
  }
  if(bgBlur>0){ ctx.filter='blur('+bgBlur+'px)'; ctx.drawImage(layer,0,0); ctx.filter='none'; }
  // 合成：人物αがあればそれで前景を抜き出して前面に
  wctx.clearRect(0,0,w,h);
  wctx.drawImage(layer,0,0);
  if(state.masks.alpha){
    const fg = work.cloneNode(true); const fgc=fg.getContext('2d'); fg.width=w; fg.height=h;
    fgc.putImageData(state.img,0,0);
    wctx.drawImage(fg,0,0);
  }else{
    // αがなければそのまま（見た目だけのBG差し替え）
    wctx.drawImage(imgEl,0,0);
  }
  log('背景適用/ぼかし完了');
}

document.getElementById('inpaint').onclick=()=>{
  // 単体HTMLの簡易フォールバック：小領域を近傍平均で埋める（デモ）
  // 本番：LaMa ONNX → 失敗時はこの処理
  if(!state.img) return;
 